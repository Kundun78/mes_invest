#!/usr/bin/env python3
"""
Script de migration pour transformer l'application Portfolio Tracker
en version multi-utilisateur et migrer les donn√©es existantes vers le compte admin.

Ce script doit √™tre ex√©cut√© une seule fois lors de la mise √† jour.
"""

import sqlite3
import hashlib
import secrets
from datetime import datetime

def migrate_to_multiuser(db_path="portfolio.db"):
    """
    Migre la base de donn√©es vers le syst√®me multi-utilisateur
    """
    print("üîÑ D√©but de la migration vers le syst√®me multi-utilisateur...")
    
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    try:
        # 1. Cr√©er les nouvelles tables d'authentification
        print("üìã Cr√©ation des tables d'authentification...")
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                email TEXT UNIQUE,
                password_hash TEXT NOT NULL,
                salt TEXT NOT NULL,
                display_name TEXT,
                is_public BOOLEAN DEFAULT FALSE,
                is_admin BOOLEAN DEFAULT FALSE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_login TIMESTAMP,
                bio TEXT,
                profile_image_url TEXT
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS user_sessions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id INTEGER,
                session_token TEXT UNIQUE NOT NULL,
                expires_at TIMESTAMP NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        ''')
        
        # 2. Ajouter les colonnes user_id aux tables existantes
        print("üîß Ajout des colonnes user_id...")
        
        tables_to_modify = [
            'platforms',
            'accounts', 
            'transactions'
        ]
        
        for table in tables_to_modify:
            try:
                cursor.execute(f'ALTER TABLE {table} ADD COLUMN user_id INTEGER')
                print(f"   ‚úÖ Colonne user_id ajout√©e √† {table}")
            except sqlite3.OperationalError as e:
                if "duplicate column name" in str(e).lower():
                    print(f"   ‚ÑπÔ∏è Colonne user_id existe d√©j√† dans {table}")
                else:
                    print(f"   ‚ùå Erreur lors de l'ajout de user_id √† {table}: {e}")
        
        # Ajouter user_id optionnel √† price_history
        try:
            cursor.execute('ALTER TABLE price_history ADD COLUMN user_id INTEGER DEFAULT NULL')
            print("   ‚úÖ Colonne user_id ajout√©e √† price_history")
        except sqlite3.OperationalError as e:
            if "duplicate column name" in str(e).lower():
                print("   ‚ÑπÔ∏è Colonne user_id existe d√©j√† dans price_history")
            else:
                print(f"   ‚ùå Erreur: {e}")
        
        # 3. Cr√©er le compte administrateur par d√©faut
        print("üëë Cr√©ation du compte administrateur...")
        
        # V√©rifier si l'admin existe d√©j√†
        cursor.execute("SELECT id FROM users WHERE username = 'kundun'")
        admin_exists = cursor.fetchone()
        
        if not admin_exists:
            # Cr√©er le compte admin
            salt = secrets.token_hex(32)
            password_hash = hashlib.pbkdf2_hmac('sha256','changeme'.encode('utf-8'), salt.encode('utf-8'), 100000)
            
            cursor.execute('''
                INSERT INTO users (username, password_hash, salt, display_name, is_admin, is_public)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', ('kundun', password_hash, salt, 'Administrateur', True, True))
            
            admin_id = cursor.lastrowid
            print(f"   ‚úÖ Compte admin cr√©√© avec l'ID {admin_id}")
        else:
            admin_id = admin_exists[0]
            print(f"   ‚ÑπÔ∏è Compte admin existe d√©j√† avec l'ID {admin_id}")
        
        # 4. Migrer toutes les donn√©es existantes vers le compte admin
        print("üì¶ Migration des donn√©es existantes vers le compte admin...")
        
        # Compter les donn√©es √† migrer
        data_counts = {}
        for table in tables_to_modify:
            cursor.execute(f'SELECT COUNT(*) FROM {table} WHERE user_id IS NULL')
            count = cursor.fetchone()[0]
            data_counts[table] = count
        
        print(f"   üìä Donn√©es √† migrer:")
        for table, count in data_counts.items():
            print(f"      - {table}: {count} enregistrements")
        
        # Effectuer la migration
        for table in tables_to_modify:
            cursor.execute(f'UPDATE {table} SET user_id = ? WHERE user_id IS NULL', (admin_id,))
            updated = cursor.rowcount
            print(f"   ‚úÖ {table}: {updated} enregistrements migr√©s")
        
        # 5. Ajouter des contraintes de cl√©s √©trang√®res (optionnel - peut poser probl√®me avec SQLite)
        print("üîó V√©rification de l'int√©grit√© des donn√©es...")
        
        # V√©rifier que toutes les donn√©es ont un user_id valide
        for table in tables_to_modify:
            cursor.execute(f'''
                SELECT COUNT(*) FROM {table} t
                LEFT JOIN users u ON t.user_id = u.id
                WHERE t.user_id IS NOT NULL AND u.id IS NULL
            ''')
            orphaned = cursor.fetchone()[0]
            if orphaned > 0:
                print(f"   ‚ö†Ô∏è {table}: {orphaned} enregistrements avec user_id invalide")
            else:
                print(f"   ‚úÖ {table}: Int√©grit√© OK")
        
        # 6. Ajouter des index pour am√©liorer les performances
        print("‚ö° Cr√©ation des index pour les performances...")
        
        indexes = [
            ('idx_platforms_user', 'CREATE INDEX IF NOT EXISTS idx_platforms_user ON platforms(user_id)'),
            ('idx_accounts_user', 'CREATE INDEX IF NOT EXISTS idx_accounts_user ON accounts(user_id)'),
            ('idx_transactions_user', 'CREATE INDEX IF NOT EXISTS idx_transactions_user ON transactions(user_id)'),
            ('idx_transactions_date', 'CREATE INDEX IF NOT EXISTS idx_transactions_date ON transactions(transaction_date)'),
            ('idx_users_username', 'CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)'),
            ('idx_sessions_token', 'CREATE INDEX IF NOT EXISTS idx_sessions_token ON user_sessions(session_token)'),
        ]
        
        for index_name, index_sql in indexes:
            try:
                cursor.execute(index_sql)
                print(f"   ‚úÖ Index {index_name} cr√©√©")
            except sqlite3.OperationalError as e:
                print(f"   ‚ÑπÔ∏è Index {index_name}: {e}")
        
        # 7. Mettre √† jour les contraintes UNIQUE pour inclure user_id (pour les plateformes)
        print("üîí Mise √† jour des contraintes...")
        
        # Note: SQLite ne permet pas de modifier facilement les contraintes
        # Cette partie pourrait n√©cessiter une recr√©ation de table si n√©cessaire
        
        # Valider la migration
        print("‚úÖ Validation de la migration...")
        
        cursor.execute("SELECT COUNT(*) FROM users WHERE is_admin = TRUE")
        admin_count = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM platforms WHERE user_id = ?", (admin_id,))
        platforms_migrated = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM accounts WHERE user_id = ?", (admin_id,))
        accounts_migrated = cursor.fetchone()[0]
        
        cursor.execute("SELECT COUNT(*) FROM transactions WHERE user_id = ?", (admin_id,))
        transactions_migrated = cursor.fetchone()[0]
        
        print(f"""
üìä R√©sultats de la migration:
   üëë Administrateurs: {admin_count}
   üè¢ Plateformes migr√©es: {platforms_migrated}
   üíº Comptes migr√©s: {accounts_migrated}
   üí∏ Transactions migr√©es: {transactions_migrated}
        """)
        
        # Confirmer les changements
        conn.commit()
        print("üíæ Migration sauvegard√©e avec succ√®s!")
        
        return True, admin_id, {
            'platforms': platforms_migrated,
            'accounts': accounts_migrated, 
            'transactions': transactions_migrated
        }
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la migration: {e}")
        conn.rollback()
        return False, None, None
        
    finally:
        conn.close()

def verify_migration(db_path="portfolio.db"):
    """
    V√©rifie que la migration s'est bien d√©roul√©e
    """
    print("\nüîç V√©rification de la migration...")
    
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    
    try:
        # V√©rifier les tables
        tables_required = ['users', 'user_sessions']
        for table in tables_required:
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (table,))
            if cursor.fetchone():
                print(f"   ‚úÖ Table {table} existe")
            else:
                print(f"   ‚ùå Table {table} manquante")
        
        # V√©rifier les colonnes user_id
        tables_with_user_id = ['platforms', 'accounts', 'transactions']
        for table in tables_with_user_id:
            cursor.execute(f"PRAGMA table_info({table})")
            columns = [col[1] for col in cursor.fetchall()]
            if 'user_id' in columns:
                print(f"   ‚úÖ Colonne user_id existe dans {table}")
            else:
                print(f"   ‚ùå Colonne user_id manquante dans {table}")
        
        # V√©rifier l'admin
        cursor.execute("SELECT username, is_admin FROM users WHERE username = 'kundun'")
        admin = cursor.fetchone()
        if admin and admin[1]:
            print("   ‚úÖ Compte administrateur 'kundun' existe et est admin")
        else:
            print("   ‚ùå Probl√®me avec le compte administrateur")
        
        # V√©rifier que les donn√©es ont des user_id
        for table in tables_with_user_id:
            cursor.execute(f"SELECT COUNT(*) FROM {table} WHERE user_id IS NULL")
            null_count = cursor.fetchone()[0]
            if null_count == 0:
                print(f"   ‚úÖ Tous les enregistrements de {table} ont un user_id")
            else:
                print(f"   ‚ö†Ô∏è {table} a {null_count} enregistrements sans user_id")
        
        print("‚úÖ V√©rification termin√©e!")
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la v√©rification: {e}")
    
    finally:
        conn.close()

def main():
    """
    Fonction principale du script de migration
    """
    print("üöÄ Portfolio Tracker - Migration vers Multi-utilisateur")
    print("=" * 60)
    
    # Demander confirmation
    response = input("‚ö†Ô∏è Cette op√©ration va modifier votre base de donn√©es. Avez-vous fait une sauvegarde ? (oui/non): ")
    if response.lower() not in ['oui', 'yes', 'y', 'o']:
        print("‚ùå Migration annul√©e. Veuillez d'abord sauvegarder votre fichier portfolio.db")
        return
    
    # Effectuer la migration
    success, admin_id, stats = migrate_to_multiuser()
    
    if success:
        print("\nüéâ Migration r√©ussie!")
        print(f"""
üìã Prochaines √©tapes:
   1. Lancez l'application: streamlit run main.py
   2. Connectez-vous avec:
      - Nom d'utilisateur: kundun
      - Mot de passe: changeme
   3. Changez imm√©diatement le mot de passe admin
   4. Invitez d'autres utilisateurs √† cr√©er leurs comptes
   
üîí S√©curit√©:
   - Vos donn√©es existantes sont maintenant associ√©es au compte 'kundun'
   - Changez le mot de passe par d√©faut d√®s la premi√®re connexion
   - Les produits financiers restent communs √† tous les utilisateurs
        """)
        
        # V√©rification finale
        verify_migration()
        
    else:
        print("\n‚ùå Migration √©chou√©e. V√©rifiez les erreurs ci-dessus.")
        print("üí° Vous pouvez restaurer votre sauvegarde et r√©essayer.")

if __name__ == "__main__":
    main()